## 1. Three different concepts

Go has **three distinct layers** that often get conflated:

1. **Module** – versioned unit of distribution
2. **Package** – unit of compilation and namespacing
3. **Executable** – a binary produced *only* from `package main`

They are related but not interchangeable.

------

## 2. Modules: dependency and version boundaries

A **module** is defined by `go.mod`.

```text
myapp/
  go.mod   → module github.com/manavukani/myapp
```

What a module really means:

- It defines an **import path prefix**
- It defines **dependency resolution**
- It does **not** define executables

When you write:

```go
import "github.com/manavukani/myapp/foo"
```

Go resolves that path using the module graph.

------

## 3. Packages: the real unit of compilation

A **package** is:

> All `.go` files in **one directory** that declare the **same package name**

Key rules (these are non-negotiable):

- A package **cannot span multiple directories**
- A directory can contain **exactly one package** (excluding `_test`)
- The package name does **not have to match** the directory name (but usually should)

Example:

```text
myapp/
  math/
    add.go      → package math
    mul.go      → package math
```

This is **one package**, compiled as a unit.

If you create another folder:

```text
myapp/
  math/
  math/internal/
```

That is a **different package**, even if both say `package math` (this is actually illegal).

------

## 4. `package main` is a special package

`package main` is special semantically.

Rules:

- Any package named `main` **may** define a `func main()`
- Only packages named `main` can produce executables
- `func main()` must:
  - Be in `package main`
  - Have no parameters
  - Have no return values

When you run:

```bash
go build
```

Go asks: *Is the current package `main`?*

- **Yes** → produce an executable
- **No** → produce a library (`.a` internally)

------

## 5. One executable = one directory

> **Each directory builds exactly one package.**
>
> **Each `package main` directory builds exactly one executable.**

So this is perfectly normal:

```text
myapp/
  cmd/
    api/
      main.go      → package main
    worker/
      main.go      → package main
    migrate/
      main.go      → package main
```

Each folder is:

- A separate package
- A separate executable
- Built independently

```bash
go build ./cmd/api
go build ./cmd/worker
```

This is why the `cmd/` pattern exists.

------

## Question: Why “multiple main files” are allowed?

They’re **not the same package**, even if the name is the same. For example:

```text
cmd/api      → package main
cmd/worker   → package main
```

These are:

- Different directories
- Different packages
- Same *package name*, but **not the same package**

Go identifies packages by **import path**, not by name alone.

So:

```go
package main
```

is more like:

```text
<module-path>/cmd/api   → main
<module-path>/cmd/worker → main
```

The name collision is intentional and safe.

------

## 7. Bad Practices

### Same package across multiple folders

This is **not** allowed:

```
myapp/
  foo/
    a.go   → package foo
  bar/
    b.go   → package foo
```

Not because the name `foo` is reused (that part is okay as packages are resolved by import path).

It’s invalid because **there is no import path that unifies them**. So your logic for same package must be in same directory.

Go will **never** merge packages across directories, regardless of name.



### Multiple `func main()` in one directory

Also illegal:

```text
cmd/api/
  main.go     → func main()
  other.go    → func main() ❌
```

Reason:

- A package can only have one entry point
- The linker needs exactly one `main.main`

> Note: A `func main()` only becomes an executable if it is in `package main`.

------

## 8. How `go build ./...` decides what to build

When you run:

```bash
go build ./...
```

Go:

1. Walks all directories
2. Builds **all packages**
3. Produces executables **only** for `package main`
4. Silently discards library artifacts

That’s why you might see multiple binaries pop out.

------

## 9. Mental model to remember + Common structure

- **Directory = package**
- **Package name != unique identity**
- **Import path = identity**
- **`package main` = executable**
- **One directory → one binary (if main)**



| Directory   | Purpose                                    | Enforced by Go | Intended Audience   |
| ----------- | ------------------------------------------ | -------------- | ------------------- |
| `cmd/`      | Executable entry points (`package main`)   | ❌              | Humans / operators  |
| `internal/` | Private application & shared code          | ✅              | This module only    |
| `pkg/`      | Public, reusable libraries                 | ❌              | Other modules/repos |
| `api/`      | API contracts (OpenAPI, Protobuf, schemas) | ❌              | Clients & tooling   |
| `configs/`  | Non-code configuration files               | ❌              | Humans & deployment |
| `scripts/`  | Build / CI / automation scripts            | ❌              | Humans & CI systems |
| `testdata/` | Test fixtures & golden files               | ✅              | Tests only          |
| `docs/`     | Human-readable documentation               | ❌              | Developers          |
| `examples/` | Minimal usage examples                     | ❌              | Learners / users    |
| `tools/`    | Dev tools (often with `//go:build tools`)  | ❌              | Developers          |

**Only `internal/` and `testdata/` have compiler behavior**

- Everything else is convention

`pkg/` is **optional and often unnecessary** (when you don’t intend to support external consumers)

`cmd/` answers *“where do programs start?”*

`internal/` answers *“what code do we own?”*

---

## What to actively avoid as a beginner

- Creating directories “just in case”
- Mimicking Kubernetes-level layouts
- Adding `pkg/` without external users
- Deep nesting early