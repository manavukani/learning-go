# Goroutines

- A _goroutine_ is a lightweight thread managed by the Go runtime.
- Goroutines run in the same address space, so access to shared memory must be synchronized.

> **Don't communicate by sharing memory; share memory by communicating**

Means: using [channels](#Channels) (communication) to pass data between goroutines, rather than having multiple goroutines directly access the same memory (shared memory), which avoids race conditions and simplifies concurrent programming.

- Main function runs on main goroutine, and runtime stops once that is completed
	- Unless we use [WaitGroups](https://gobyexample.com/waitgroups) to wait for other goroutines to finish
- The goroutines' output may be interleaved, 
	- because goroutines are being run concurrently by the Go runtime. 
	- There is no guarantee of order

```go
package main

import (
    "fmt"
    "time"
)

func f(from string) {
    for i := range 3 {
        fmt.Println(from, ":", i)
    }
}

func main() {

    f("direct")

    go f("goroutine") // new goroutine, execute concurrently with others

    go func(msg string) {
        fmt.Println(msg)
    }("going")

    time.Sleep(time.Second)
    fmt.Println("done")
}
```

# Channels

- _Channels_ are the pipes that connect concurrent goroutines. 
- We can send values into channels from one goroutine and receive those values into another goroutine.

```go
ch <- v    // Send v to channel ch.
v := <-ch  // Receive from ch, and
           // assign value to v.
```

- By default, sends and receives block until the other side is ready. 
	- This allows goroutines to synchronize without explicit locks or condition variables.

```go
func main(){
    var c = make(chan int)
    c <- 1
    var i = <- c
    fmt.Println(i)
}

// fatal error: all goroutines are asleep - deadlock!
```
- Go would wait until someone reads from the channel but since `i` is assigned after channel call, it ends up waiting endlessly in a synchronous usage, so runtime throws deadlock error
	- Solution: using with Goroutines

Example: sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.

```go
package main

import "fmt"

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // send sum to c
}

func main() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int) // like map & slices, channels MUST be created before use
	go sum(s[:len(s)/2], c)
	go sum(s[len(s)/2:], c)
	x, y := <-c, <-c // receive from c (channel)

	fmt.Println(x, y, x+y) // -5 17 12
}
```

Note: this program does not end before both goroutines end, cause its *blocked waiting on channel receives*

# Buffered Channels
 - Need for buffered channels:
	- By default channels are **_unbuffered_**, meaning that they will **only accept sends (`chan <-`) if there is a corresponding receive (`<- chan`) ready** to receive the sent value. 
	- Also if channel has already received some value, but there is no listener, the future values would be lost/blocked, cause channel is full
- **_Buffered channels_** accept a limited number of values without a corresponding receiver for those values.
	- Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.
	- Sort of acting like a queue (fixed length), once received, value is removed from channel

```go
package main

import "fmt"

func main() {

    messages := make(chan string, 2)

    messages <- "buffered"
    messages <- "channel"

    fmt.Println(<-messages)
    fmt.Println(<-messages)
	fmt.Println(<-messages) // throws error, empty buffer

}
```

### Help goroutine finish early 
- let goroutine complete its execution by pushing its values in *buffer*
- rest of goroutines/main can then fetch values from that channel buffer and do their job 
- instead of goroutine pushing and waiting for receiver to consume values one-by-one

```go
func process(c chan int){
    defer close(c)
    for i := range 5{
        c<-i
    }
    fmt.Print("Ending process ")
}

func main(){
    var queue = make(chan int, 5)
    // var queue = make(chan int)
    go process(queue)
    for i:= range queue{
        fmt.Print(i, " ")
        time.Sleep(time.Second*1)
    }
}

// WITH BUFFER: Ending process..0 1 2 3 4 
// WITHOUT BUFFER: 0 1 2 3 4 Ending process..
```

# TODO:
- [Channel Synchronization](https://gobyexample.com/channel-synchronization)
-  [WaitGroup](https://gobyexample.com/waitgroups)
-  [Channel Directions](https://gobyexample.com/channel-directions)
- [Timeouts](https://gobyexample.com/timeouts)
- [Non-Blocking Channel Operations](https://gobyexample.com/non-blocking-channel-operations)
- [Closing Channel](https://gobyexample.com/closing-channels)
- so on....


# Range and Close

- A sender can `close` a channel to indicate that no more values will be sent. 
- Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression
- Example: 
```go
v, ok := <-ch
// ok is true when channel open + values incoming
// ok is false when no more values to receive and channel is closed
```

> ==Only the sender should close a channel, **NEVER** the receiver. Sending on a closed channel will cause a *panic*.==

```go
package main

import "fmt"

func main() {

    queue := make(chan string, 2)
    queue <- "one"
    queue <- "two"
    close(queue) // IMP here cause we are using channel as range in loop
				 // it not closed, would try to read and throw deadlock err

	// receives values from the channel repeatedly (until its closed, if closed)
    for elem := range queue { 
        fmt.Println(elem)
    }
}

// one
// two
```

This `range` iterates over each element as it’s received from `queue`. Because we `close`d the channel above, the iteration terminates after receiving the 2 elements.

Note: Channels aren't like files; you don't usually need to close them. Closing is **ONLY necessary when the receiver must be told there are no more values coming**, such as to terminate a `range` loop.

# Select

`select` statement 
- lets a goroutine wait on *multiple* communication operations
- blocks until one of its cases can run, then it executes that case
- chooses one at random if *multiple* are ready.

```go
package main  

import (
    "fmt"
) 

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    // goroutine 1
    go func() {
        ch1 <- "message from channel 1"
        }()

    // goroutine 2
    go func() {
        ch2 <- "message from channel 2"
    }()
  
    // Listen to both channels
	select {
	case msg1 := <-ch1:
		fmt.Println("Received:", msg1)
	case msg2 := <-ch2:
		fmt.Println("Received:", msg2)
	}
}
```
- Output differs everytime based who executed first
- If want to model - based on random selection, use buffered channel to finish execution early


What “ready” means in `select` (For **unbuffered channels**):

| Operation       | When is it ready?                                                   |
| --------------- | ------------------------------------------------------------------- |
| `c <- x` (send) | Only when some goroutine is **already waiting to receive** from `c` |
| `<-c` (receive) | Only when some goroutine is **already trying to send** on `c`       |

```go
func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit: // no goroutine is receiving from c, select chooses quit case
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c) // goroutine is waiting, c <- x is ready for select 
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
```


# Non-Blocking Channel Operations: default selection

- The `default` case in a `select` is run if no other case is ready.
- Use a `default` case to try a send or receive without blocking

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	tick := time.Tick(100 * time.Millisecond)
	boom := time.After(250 * time.Millisecond)
	for {           // blocking the main goroutine from ending
					// can only end when infinite for loop returns
		select {
		case <-tick:
			fmt.Printf("tick .\n")
		case <-boom:
			fmt.Printf("BOOM!\n")
			return
		default:
			fmt.Printf("     .\n")
			time.Sleep(50 * time.Millisecond)
		}
	}
}

//      . --> every 50ms
//      . --> every 50ms
// tick . --> every 100ms
//      . --> every 50ms
//      . --> every 50ms
// tick . --> every 100ms
//      . --> every 50ms
// BOOM!  --> at 250ms, also returns so main goroutine ends
```

# sync.Mutex (Mutual Exclusion)

- If multiple goroutines try to modify the same value, say in a map
	- when passed by reference pointer, they access the same map value
	- end up doing concurrent map writes
```go
type Counter struct {
	v map[string]int
}
// increment method
func [c *Counter] Inc(key string){
	c.v[key]++
}

// get method
func [c *Counter] Get(key string) int{
	return c.v[key]
}

func main (){
	c:= Counter{v: make(map[string]int)}
	for i:=1; i<1000; i++ {
		go c.Inc("somekey") // concurrent writes!!
	}
	
	time.Sleep(time.Second)
	fmt.Println(c.Get("somekey"))
}
```

But what if we don't need communication? What if we just want to make sure only one goroutine can access a variable at a time to avoid conflicts? 
- Mutual Exclusion, just like OS

Go's standard library provides mutual exclusion with [`sync.Mutex`](https://go.dev/pkg/sync/#Mutex) and its two methods:
- `Lock`
- `Unlock`

We can define a block of code to be executed in mutual exclusion by surrounding it with a call to `Lock` and `Unlock` as shown on the `Inc` method.

We can also use `defer` to ensure the mutex will be unlocked as in the `Get` method.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

type SafeCounter struct {
	mu sync.Mutex // IMPORTANT!!
	v  map[string]int
}

func (c *SafeCounter) Inc(key string) {
	c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v.
	c.v[key]++
	c.mu.Unlock() // Unlock later on
}

func (c *SafeCounter) Get(key string) int {
	c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v.
	defer c.mu.Unlock() // Unlock once func/method is over 
	return c.v[key]
}

func main() {
	c := SafeCounter{v: make(map[string]int)}
	for i := 0; i < 1000; i++ {
		go c.Inc("somekey")
	}

	time.Sleep(time.Second)
	fmt.Println(c.Get("somekey"))
}
```


# Exercise - Equivalent Binary Trees

A function to check whether two binary trees store the same sequence is quite complex in most languages. We'll use Go's concurrency and channels to write a simple solution.

The function `tree.New(k)` constructs a randomly-structured (but always sorted) binary tree holding the values `k`, `2k`, `3k`, ..., `10k`.

```go
package main

import "golang.org/x/tour/tree"
import "fmt"

// Walk walks the tree t sending all values
// from the tree to the channel ch.
func Walk(t *tree.Tree, ch chan int) {
	
	// anonymous function cannot refer to itself unless it already exists
	// helper for recursion, without it caller need to close channel
	var dfs func(*tree.Tree)

	dfs = func(t *tree.Tree) {
		if t == nil {
			return
		}
		dfs(t.Left)
		ch <- t.Value
		dfs(t.Right)
	}

	dfs(t)
	close(ch) // only the sender should close channel
}


// Same determines whether the trees
// t1 and t2 contain the same values.
func Same(t1, t2 *tree.Tree) bool {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go Walk(t1, ch1)
	go Walk(t2, ch2)

	for {
		v1, ok1 := <-ch1
		v2, ok2 := <-ch2

		if ok1 != ok2 {
			return false
		}
		if !ok1 { // both channels closed
			return true
		}
		if v1 != v2 {
			return false
		}
	}
}


func main() {
	ch := make(chan int)
	t := tree.New(1)
	go Walk(t, ch)
	fmt.Println(t) // randomly generated tree structure with values 1 - 10
	for v := range ch {
		fmt.Println(v)
	}

	fmt.Println(Same(tree.New(1), tree.New(1))) // true
	fmt.Println(Same(tree.New(1), tree.New(2))) // false

}
```
